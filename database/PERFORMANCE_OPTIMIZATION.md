# Оптимизация производительности EventsList

## Проблемы, которые были решены

### 1. Медленная загрузка списка событий
**Причины:**
- Множественные запросы к базе данных для вкладок "Мои мероприятия" и "Архив"
- Отсутствие составных индексов для оптимизации запросов
- Короткое время жизни кэша (30 секунд)
- Отсутствие предзагрузки соседних вкладок

### 2. Частые ре-рендеры компонентов
**Причины:**
- Не мемоизированные компоненты и функции
- Пересоздание объектов на каждом рендере
- Отсутствие оптимизации рендеринга списков

## Реализованные оптимизации

### 1. Оптимизация базы данных

#### Составные индексы
```sql
-- Индекс для быстрого поиска активных событий по дате
CREATE INDEX idx_events_status_date ON events(status, date) WHERE status = 'active';

-- Индекс для быстрого поиска событий пользователя
CREATE INDEX idx_events_created_by_private_date ON events(created_by, is_private, date);

-- Индекс для быстрого поиска откликов пользователя
CREATE INDEX idx_event_responses_user_status ON event_responses(user_telegram_id, response_status);
```

#### RPC функции для оптимизации запросов
- `get_user_events_optimized()` - объединяет несколько запросов в один с UNION
- `get_user_archive_optimized()` - аналогично для архива
- `get_available_events_optimized()` - оптимизированный поиск доступных событий

### 2. Оптимизация кэширования

#### Увеличенное время жизни кэша
- **Было:** 30 секунд
- **Стало:** 2 минуты (120 секунд)

#### Предзагрузка соседних вкладок
- Автоматическая загрузка соседних вкладок в фоне
- Умная проверка актуальности кэша перед предзагрузкой

### 3. Оптимизация React компонентов

#### Мемоизация компонентов
- `EventCard` - мемоизирован с React.memo
- `EventsGrid` - отдельный мемоизированный компонент для списка
- `LoadingGrid` - мемоизированный компонент загрузки
- `EmptyState` - мемоизированный компонент пустого состояния

#### Мемоизация функций и значений
- `useCallback` для всех обработчиков событий
- `useMemo` для вычисляемых значений (заголовки, счетчики)
- Предотвращение пересоздания объектов

## Инструкции по применению

### 1. Применение оптимизаций базы данных

```bash
# Подключитесь к вашей базе данных Supabase
psql "postgresql://[user]:[password]@[host]:[port]/[database]"

# Выполните скрипт оптимизации
\i database/performance_optimization.sql
```

### 2. Проверка применения индексов

```sql
-- Проверьте, что индексы созданы
SELECT indexname, tablename FROM pg_indexes 
WHERE schemaname = 'public' 
AND indexname LIKE 'idx_%';

-- Проверьте статистику использования индексов
SELECT * FROM get_index_usage_stats();
```

### 3. Проверка RPC функций

```sql
-- Проверьте, что функции созданы
SELECT routine_name, routine_type 
FROM information_schema.routines 
WHERE routine_schema = 'public' 
AND routine_name LIKE '%_optimized';

-- Тестирование функций
SELECT * FROM get_user_events_optimized(123456789, 10);
SELECT * FROM get_available_events_optimized(20);
```

## Мониторинг производительности

### 1. Проверка использования индексов

```sql
-- Статистика сканирования индексов
SELECT 
    schemaname,
    tablename,
    indexname,
    idx_scan,
    idx_tup_read,
    idx_tup_fetch
FROM pg_stat_user_indexes 
WHERE schemaname = 'public'
ORDER BY idx_scan DESC;
```

### 2. Анализ медленных запросов

```sql
-- Включите логирование медленных запросов (если доступно)
-- log_min_duration_statement = 1000  -- логировать запросы > 1 секунды
```

### 3. Мониторинг в браузере

Откройте DevTools → Network → XHR для отслеживания:
- Время ответа API запросов
- Количество запросов при переключении вкладок
- Использование кэша (должно быть меньше запросов)

## Ожидаемые результаты

### Улучшение производительности
- **Загрузка вкладок:** 2-5x быстрее благодаря RPC функциям
- **Переключение вкладок:** мгновенно при попадании в кэш
- **Ре-рендеры:** значительно меньше благодаря мемоизации

### Улучшение UX
- Предзагрузка соседних вкладок для мгновенного переключения
- Более плавная анимация и отзывчивость интерфейса
- Меньше "мерцаний" при обновлении данных

## Fallback механизмы

Все оптимизации включают fallback к старым методам:
- Если RPC функция недоступна → используется legacy метод
- Если кэш поврежден → выполняется новый запрос
- Если предзагрузка не удалась → игнорируется без ошибок

## Дополнительные рекомендации

### 1. Мониторинг размера кэша
```javascript
// В DevTools Console
console.log('Cache size:', eventsCache.current.size);
```

### 2. Очистка кэша при необходимости
```javascript
// Программная очистка кэша
eventsCache.current.clear();
```

### 3. Настройка времени жизни кэша
```javascript
// В EventsList.tsx можно изменить CACHE_DURATION
const CACHE_DURATION = 120000; // 2 минуты
```

## Troubleshooting

### Если оптимизации не работают

1. **Проверьте логи консоли** на наличие ошибок RPC функций
2. **Убедитесь, что индексы созданы** в базе данных
3. **Проверьте права доступа** к RPC функциям в Supabase
4. **Очистите кэш браузера** и перезагрузите страницу

### Если производительность не улучшилась

1. **Проверьте Network tab** в DevTools
2. **Убедитесь, что используются RPC функции** (в логах должно быть "optimized")
3. **Проверьте размер данных** - возможно, нужно уменьшить лимит
4. **Проанализируйте план выполнения** запросов в базе данных 